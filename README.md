# Review week38 tuesday  


  
## [Exercises JPA Relations](https://docs.google.com/document/d/18gU-VJALIQTQeoMx-jmhVq9fb_G7PN4HC_qr7nArkhg/edit#)   
### Collections of basic type  

#### 1.  [In your NetBeans project, create an Entity class Customer,  with a firstName and lastName property, sufficient constructors and getters/setters](https://github.com/cph-ms782/review_week38_tuesday/blob/a5b11b3bca65d8cf063b30e57c73a24ae26cf99c/src/main/java/entities/Customer.java#L18)  

#### 2.[Provide the Customer class with a list of hobbies](https://github.com/cph-ms782/review_week38_tuesday/blob/a5b11b3bca65d8cf063b30e57c73a24ae26cf99c/src/main/java/entities/Customer.java#L29)  

#### 3.[ Add a class, Tester.java, to test drive (manually, not with JUnit) the Customer class and create and persist a few customers with some hobbies](https://github.com/cph-ms782/review_week38_tuesday/blob/master/src/main/java/test/Tester.java)  

#### 4.[What if you don’t like the names of the generated table and its column names](https://github.com/cph-ms782/review_week38_tuesday/blob/7475e9e6acd397f7fbf841823579e9163ab8be5a/src/main/java/entities/Customer.java#L27)  
  


### Maps of Basic Types  
Bloooob, do you like what you see?  
_**There's a blob inside the tabel**_  


## JPA Entity Mappings  

### 1) [One to One – Unidirectional](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToOne-Unidirectional/src/main/java)  
* how an OO-language implements OneToOne relations and how a relational database does the same.  
_**OO implements OneToOne by the annotation and the reference variable to the other entity. TheDB does it by a foreign key.**_  

### 2) [One to One – Bidirectional](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToOne-Bidirectional/src/main/java)  
  * how would you show bidirectional using UML, and how is it implemented in your two entity classes:  
_**UML: Two boxes with arrow connecting both boxes both ways and two 1's above arrow.  
Each entity has the other entity's type and reference variable**_  

_**Addresse now has a @OneToOne(cascade = CascadeType.PERSIST, **mappedBy = "address"**) part connecting it to the reference in the Customer class**_  

* Run the project and investigate the generated tables (the foreign key). Is there any difference compared to the previous exercise. If not explain why.  
_**There's no difference in the two tables. The database can always go both ways when there's a foreign key. The objects has to be told to go both ways.**_  
 

### 3) [OneToMany (unidirectional)](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToMany-Unidirectional/src/main/java)  


 * If you (as us) don't like the number of generated tables generated by this strategy, you can use the @JoinColumn annotation to implement the relation using a foreign key. Do this, but before you test, delete ALL generated tables in the database  
_**Extra Customer_ID column from address table is gone**_



### 4) [OneToMany (bidirectional)](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToMany-Bidirectional/src/main/java)  

 * Run the project and investigate the generated tables (the foreign key)  
_**3 tables. One is the Customer table. Second is the Address table. Third a join table joining the other two tables.**_

 * Create a "test" method and insert a number of Customers with Addresses into the tables, using JPA. Which extra step is required for this strategy compared to OneToMany unidirectional?  
_**There needs to be a @ManoToOne annotation in the other table**_   

