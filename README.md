# review week38 tuesday  
[return to overview](https://github.com/cph-ms782/review_week38)  

  
## [Exercises JPA Relations](https://docs.google.com/document/d/18gU-VJALIQTQeoMx-jmhVq9fb_G7PN4HC_qr7nArkhg/edit#)   
### Collections of basic type  

#### 1.[Link](https://github.com/cph-ms782/review_week38_tuesday/blob/a5b11b3bca65d8cf063b30e57c73a24ae26cf99c/src/main/java/entities/Customer.java#L18)  

#### 2.[Link](https://github.com/cph-ms782/review_week38_tuesday/blob/a5b11b3bca65d8cf063b30e57c73a24ae26cf99c/src/main/java/entities/Customer.java#L29)  

#### 3.[Link](https://github.com/cph-ms782/review_week38_tuesday/blob/master/src/main/java/test/Tester.java)  

#### 4.[Link](https://github.com/cph-ms782/review_week38_tuesday/blob/7475e9e6acd397f7fbf841823579e9163ab8be5a/src/main/java/entities/Customer.java#L27)  
  


### Maps of Basic Types  
Bloooob, do you like what you see?  

If not, add the following annotations to the map:
@ElementCollection(fetch = FetchType.LAZY)
@MapKeyColumn(name = "PHONE")
@Column(name="Description")

Execute and observe the generated columns and values. Make sure you understand the purpose of each of the annotations

## JPA Entity Mappings  

### 1) [One to One – Unidirectional](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToOne-Unidirectional/src/main/java)  
* how an OO-language implements OneToOne relations and how a relational database does the same.

OO implements OneToOne by the annotation and the reference variable to the other entity. TheDB does it by a foreign key.  

### 2) [One to One – Bidirectional](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToOne-Bidirectional/src/main/java)  
  * how would you show bidirectional using UML, and how is it implemented in your two entity classes:  
  
_UML: Two boxes with arrow connecting both boxes both ways and two 1's above arrow.  
Each entity has the other entity's type and reference variable_  

* Go to the Address class. Investigate and understand the generated code

_Addresse now has a @OneToOne(cascade = CascadeType.PERSIST, **mappedBy = "address"**) part connecting it to the reference in the Customer class_

* Run the project and investigate the generated tables (the foreign key). Is there any difference compared to the previous exercise. If not explain why.  

_There's no difference in the two tables. The database can always go both ways when there's a foreign key. The objects has to be told to go both ways._
 

### 3) [OneToMany (unidirectional)](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToMany-Unidirectional/src/main/java)  
 * How many tables were generated? Explain the purpose of each of the tables  

__ 

 * If you (as us) don't like the number of generated tables generated by this strategy, you can use the @JoinColumn annotation to implement the relation using a foreign key. Do this, but before you test, delete ALL generated tables in the database  

_Extra Customer_ID column from address table is gone_



### 4) [OneToMany (bidirectional)](https://github.com/cph-ms782/review_week38_tuesday/tree/master/OneToMany-Bidirectional/src/main/java)  
 * Observe the generated code, especially where we find the mappedBy value. Explain  
 
__

 * Run the project and investigate the generated tables (the foreign key)  
 
_3 tables. One is the Customer table. Second is the Address table. Third a join table joining the other two tables._

 * Create a "test" method and insert a number of Customers with Addresses into the tables, using JPA. Which extra step is required for this strategy compared to OneToMany unidirectional?  
__  

[return to overview](https://github.com/cph-ms782/review_week38)  

